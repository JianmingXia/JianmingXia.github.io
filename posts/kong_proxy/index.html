<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="通过详细解释Kong的路由功能和内部工作原理来介绍Kong的代理功能  Kong公开几个接口，可以调整两个配置属性：  proxy_listen：定义了一个地址/端口列表——Kong将接受来自客户端的流量并代理上游服务 admin_listen：同样定义了一个地址/端口列表——但这些仅限于管理员访问  从0.13.0版本开始，API实体被弃用，使用 Routes 及 Services 实体替代">
<meta name="keywords" content="API Gateway,Kong">
<meta property="og:type" content="article">
<meta property="og:title" content="Kong——Proxy文档">
<meta property="og:url" content="https://blog.ryoma.top/posts/kong_proxy/index.html">
<meta property="og:site_name" content="Ryoma&#39;s Blog">
<meta property="og:description" content="通过详细解释Kong的路由功能和内部工作原理来介绍Kong的代理功能  Kong公开几个接口，可以调整两个配置属性：  proxy_listen：定义了一个地址/端口列表——Kong将接受来自客户端的流量并代理上游服务 admin_listen：同样定义了一个地址/端口列表——但这些仅限于管理员访问  从0.13.0版本开始，API实体被弃用，使用 Routes 及 Services 实体替代">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2018/png/92822/1538126272900-eb1ca537-d0d3-433e-bb77-15ddd385e8b4.png">
<meta property="og:updated_time" content="2018-10-16T11:47:49.213Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kong——Proxy文档">
<meta name="twitter:description" content="通过详细解释Kong的路由功能和内部工作原理来介绍Kong的代理功能  Kong公开几个接口，可以调整两个配置属性：  proxy_listen：定义了一个地址/端口列表——Kong将接受来自客户端的流量并代理上游服务 admin_listen：同样定义了一个地址/端口列表——但这些仅限于管理员访问  从0.13.0版本开始，API实体被弃用，使用 Routes 及 Services 实体替代">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2018/png/92822/1538126272900-eb1ca537-d0d3-433e-bb77-15ddd385e8b4.png">






  <link rel="canonical" href="https://blog.ryoma.top/posts/kong_proxy/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Kong——Proxy文档 | Ryoma's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ryoma's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">纸上得来终觉浅</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于我</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://blog.ryoma.top/posts/kong_proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ryoma">
      <meta itemprop="description" content="Ryoma's Blog">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ryoma's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Kong——Proxy文档
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-28 20:30:00" itemprop="dateCreated datePublished" datetime="2018-09-28T20:30:00+08:00">2018-09-28</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/微服务/" itemprop="url" rel="index"><span itemprop="name">微服务</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kong/" itemprop="url" rel="index"><span itemprop="name">Kong</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/posts/kong_proxy/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="posts/kong_proxy/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>通过详细解释Kong的路由功能和内部工作原理来介绍Kong的代理功能</p>
</blockquote>
<p>Kong公开几个接口，可以调整两个配置属性：</p>
<ul>
<li>proxy_listen：定义了一个地址/端口列表——Kong将接受来自客户端的流量并代理上游服务</li>
<li>admin_listen：同样定义了一个地址/端口列表——但这些仅限于管理员访问</li>
</ul>
<p>从0.13.0版本开始，API实体被弃用，使用 Routes 及 Services 实体替代</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>client：指下游客户端向Kong的代理端口发出请求</li>
<li>upstream service：指位于Kong后面的API/服务，客户端请求被转发到该服务</li>
<li>Service：服务实体是每个上游服务的抽象。如数据转换微服务、计费API等</li>
<li>Route：指Kong实体——Route是进入Kong的入口，并为要匹配的请求定义规则，并路由到给定的服务</li>
<li>Plugin：指Kong的Plugins，在代理生命周期中运行的业务逻辑。插件可以通过管理API进行配置——可以全局配置(所有入口)，也可以在特定的路由和服务上配置<a id="more"></a>
</li>
</ul>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>从上层看，Kong在其配置的代理端口上监听HTTP流量(默认为8000和8443)。Kong将根据配置的路由评估任何传入HTTP请求，并尝试找到匹配的路由。如果请求与路由规则匹配，Kong将处理代理请求。因为每个路由都链接到一个服务，Kong将运行在路由及其关联服务上配置的插件，然后代理上游的请求。<br>可以通过Kong的Admin API管理路由——hosts、paths和methods都可以作为匹配规则。</p>
<h3 id="未匹配的请求"><a href="#未匹配的请求" class="headerlink" title="未匹配的请求"></a>未匹配的请求</h3><p>未匹配到路由/路由未配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Date: Fri, 28 Sep 2018 08:08:36 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Server: kong/0.14.1</span><br><span class="line">Content-Length: 58</span><br><span class="line"></span><br><span class="line">&#123;&quot;message&quot;:&quot;no route and no API found with those values&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>返回的mesage提到了API，出于向后兼容的原因，Kong 0.13仍然支持API实体(如果匹配路由失败，则尝试匹配配置的API)</p>
</blockquote>
<h2 id="如何配置服务"><a href="#如何配置服务" class="headerlink" title="如何配置服务"></a>如何配置服务</h2><blockquote>
<p>在<a href="https://docs.konghq.com/0.14.x/getting-started/configuring-a-service/" target="_blank" rel="noopener">文档</a>中解释了如何通过Admin API配置</p>
</blockquote>
<h3 id="添加Service"><a href="#添加Service" class="headerlink" title="添加Service"></a>添加Service</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8001/services/ \</span><br><span class="line">    -d &apos;name=foo-service&apos; \</span><br><span class="line">    -d &apos;url=http://foo-service.com&apos;</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Fri, 28 Sep 2018 08:16:33 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Server: kong/0.14.1</span><br><span class="line">Content-Length: 259</span><br><span class="line"></span><br><span class="line">&#123;&quot;host&quot;:&quot;foo-service.com&quot;,&quot;created_at&quot;:1538122593,&quot;connect_timeout&quot;:60000,&quot;id&quot;:&quot;1c0a70da-ca56-44bb-8b4b-3e10a154450f&quot;,&quot;protocol&quot;:&quot;http&quot;,&quot;name&quot;:&quot;foo-service&quot;,&quot;read_timeout&quot;:60000,&quot;port&quot;:80,&quot;path&quot;:null,&quot;updated_at&quot;:1538122593,&quot;retries&quot;:5,&quot;write_timeout&quot;:60000&#125;</span><br></pre></td></tr></table></figure>
<p>在Kong注册一个名为“foo-service”的服务，指向<strong><a href="http://foo-service.com" target="_blank" rel="noopener">http://foo-service.com</a></strong>(上游)</p>
<p>Note: url参数是用来填充的简单参数——一次添加protocol, host, port, and path</p>
<h3 id="添加Route"><a href="#添加Route" class="headerlink" title="添加Route"></a>添加Route</h3><p>为了通过Kong向该服务发送请求——我们需要指定一条路由，它充当Kong的入口</p>
<h4 id="routes"><a href="#routes" class="headerlink" title="routes"></a>routes</h4><p>其中service.id是添加Service时返回的id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8001/routes/ \</span><br><span class="line">    -d &apos;hosts[]=example.com&apos; \</span><br><span class="line">    -d &apos;paths[]=/foo&apos; \</span><br><span class="line">    -d &apos;service.id=1c0a70da-ca56-44bb-8b4b-3e10a154450f&apos;</span><br><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Date: Fri, 28 Sep 2018 08:28:04 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Server: kong/0.14.1</span><br><span class="line">Content-Length: 295</span><br><span class="line"></span><br><span class="line">&#123;&quot;created_at&quot;:1538123284,&quot;strip_path&quot;:true,&quot;hosts&quot;:[&quot;example.com&quot;],&quot;preserve_host&quot;:false,&quot;regex_priority&quot;:0,&quot;updated_at&quot;:1538123284,&quot;paths&quot;:[&quot;\/foo&quot;],&quot;service&quot;:&#123;&quot;id&quot;:&quot;1c0a70da-ca56-44bb-8b4b-3e10a154450f&quot;&#125;,&quot;methods&quot;:null,&quot;protocols&quot;:[&quot;http&quot;,&quot;https&quot;],&quot;id&quot;:&quot;b3bc45dc-0805-4a03-9298-e76e1175c096&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="services-xxx-routes"><a href="#services-xxx-routes" class="headerlink" title="services/xxx/routes"></a>services/xxx/routes</h4><p>在入门篇中，请求的是指定service对应接口，这里有个小不同<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST \</span><br><span class="line">  --url http://localhost:8001/services/example-service/routes \</span><br><span class="line">  --data &apos;hosts[]=example.com&apos;</span><br></pre></td></tr></table></figure></p>
<p>现在，我们已经配置了一条路由来匹配给定hosts和paths的请求，并将它们转发到我们配置的<strong>foo-service</strong>，从而将该流量代理到<a href="http://foo-service.com" target="_blank" rel="noopener">http://foo-service.com</a></p>
<p>Kong是一个透明的代理，默认情况下将把请求转发至未受影响的上游服务，除了HTTP规范要求的Connection、Date等不同的header之外</p>
<h2 id="路由及匹配功能"><a href="#路由及匹配功能" class="headerlink" title="路由及匹配功能"></a>路由及匹配功能</h2><blockquote>
<p>Kong如何将请求与已配置的hosts、paths和methods匹配<br>注意：这三个字段是可选的，但至少指定一个</p>
</blockquote>
<p>路由匹配的要求：</p>
<ul>
<li>请求必须包含所有已配置字段</li>
<li>请求中字段的值必须至少匹配一个配置值(虽然field配置接受一个或多个值，但请求只需要其中一个值就可以认为是匹配的)<br>Note：这里第二个要求指的是具体field匹配一个即可，比如methods可能有多个，只匹配一个即可，毕竟也没办法带多个method类型</li>
</ul>
<h3 id="匹配案例"><a href="#匹配案例" class="headerlink" title="匹配案例"></a>匹配案例</h3><h4 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"example.com"</span>, <span class="string">"foo-service.com"</span>],</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"/foo"</span>, <span class="string">"/bar"</span>],</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"GET"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="匹配通过"><a href="#匹配通过" class="headerlink" title="匹配通过"></a>匹配通过</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">GET /bar HTTP/1.1</span><br><span class="line">Host: foo-service.com</span><br><span class="line"></span><br><span class="line">GET /foo/hello/world HTTP/1.1</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure>
<h4 id="匹配失败"><a href="#匹配失败" class="headerlink" title="匹配失败"></a>匹配失败</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// paths不匹配</span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">// methods不匹配</span><br><span class="line">POST /foo HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">// hosts不匹配</span><br><span class="line">GET /foo HTTP/1.1</span><br><span class="line">Host: foo.com</span><br></pre></td></tr></table></figure>
<h3 id="Host-Header"><a href="#Host-Header" class="headerlink" title="Host Header"></a>Host Header</h3><p>基于Host header路由请求是通过Kong代理通信的最直接的方式，特别是因为这是HTTP Host header的预期用法——Kong使得通过Route实体的host字段进行操作变得很容易</p>
<ul>
<li>hosts 接受多个值，当通过Admin API指定它们时，必须用逗号分隔</li>
<li>hosts 接受多个值，在JSON payload中很容易表示</li>
</ul>
<h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p>JSON payload：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:<span class="number">8001</span>/routes/ \</span><br><span class="line">    -H <span class="string">'Content-Type: application/json'</span> \</span><br><span class="line">    -d <span class="string">'&#123;"hosts":["example.com", "foo-service.com"]&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>hosts[]：由于Admin API也支持form-urlencoded内容类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8001/routes/ \</span><br><span class="line">    -d &apos;hosts[]=example.com&apos; \</span><br><span class="line">    -d &apos;hosts[]=foo-service.com&apos;</span><br></pre></td></tr></table></figure></p>
<p>按照上述的方式添加Route后，如果要匹配，则在请求头中需要满足以下二者之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host: example.com</span><br><span class="line">Host: foo-service.com</span><br></pre></td></tr></table></figure></p>
<h4 id="使用通配符的主机名"><a href="#使用通配符的主机名" class="headerlink" title="使用通配符的主机名"></a>使用通配符的主机名</h4><p>为了提供灵活性，Kong允许在hosts字段中使用通配符指定主机名。通配符主机名允许任何匹配的Host header满足条件，从而匹配给定的路由。<br>通配符主机名必须在域的最左或最右标签上仅包含一个星号：</p>
<ul>
<li>*.example.com：允许如a.example.com和x.y.example.com匹配</li>
<li>example.*：将允许如example.com和example.org匹配</li>
</ul>
<p>完整例子如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"*.example.com"</span>, <span class="string">"service.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>匹配成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: an.example.com</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: service.com</span><br></pre></td></tr></table></figure></p>
<h4 id="preserve-host"><a href="#preserve-host" class="headerlink" title="preserve_host"></a>preserve_host</h4><p><img src="https://cdn.nlark.com/yuque/0/2018/png/92822/1538126272900-eb1ca537-d0d3-433e-bb77-15ddd385e8b4.png" alt="image.png | left | 751x127"></p>
<p>代理时，Kong的默认行为是将上游请求的主机头设置为服务主机中指定的主机名。preserve_host字段接受一个布尔标记，指示Kong不要这样做</p>
<p>当没有配置preserve_host 时，及Route的配置如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"service.com"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: service.com</span><br></pre></td></tr></table></figure></p>
<p>Kong将从服务的主机属性中提取Host header，向上游发起请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: &lt;my-service-host.com&gt;</span><br></pre></td></tr></table></figure></p>
<p>在路由中配置preserve_host=true ：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"service.com"</span>],</span><br><span class="line">    <span class="attr">"preserve_host"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>发起同样的请求，Kong将保留客户端请求上的Host，向上游请求:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: service.com</span><br></pre></td></tr></table></figure></p>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>要匹配路由的另一种方法是通过请求路径——为了满足这个路由条件，客户端请求的路径必须以paths属性的一个值为前缀</p>
<ul>
<li>默认情况下，Kong将在不改变URL路径的情况下向上游代理请求</li>
<li>首先计算最长路径：允许用两条路径定义两条路由：如/service和/service/resource</li>
</ul>
<h4 id="基础配置-1"><a href="#基础配置-1" class="headerlink" title="基础配置"></a>基础配置</h4><p>假设路由配置如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"/service"</span>, <span class="string">"/hello/world"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>匹配成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /service HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">GET /service/resource?param=value HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line"></span><br><span class="line">GET /hello/world/resource HTTP/1.1</span><br><span class="line">Host: anything.com</span><br></pre></td></tr></table></figure></p>
<h4 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h4><p>Kong支持通过PCRE (Perl兼容正则表达式)对路由路径字段进行正则匹配，可以同时将路径作为前缀和regex分配给路由。</p>
<p>假设路由配置如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"/users/\d+/profile"</span>, <span class="string">"/following"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>匹配成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /following HTTP/1.1</span><br><span class="line">Host: ...</span><br><span class="line"></span><br><span class="line">GET /users/123/profile HTTP/1.1</span><br><span class="line">Host: ...</span><br></pre></td></tr></table></figure></p>
<h5 id="匹配顺序"><a href="#匹配顺序" class="headerlink" title="匹配顺序"></a>匹配顺序</h5><p>前面提到过，Kong按长度计算前缀路径：最长的前缀路径首先计算。然而，Kong将根据路由的regex_priority属性评估regex路径，以下列路由为例：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"paths"</span>: [<span class="string">"/status/\d+"</span>],</span><br><span class="line">        <span class="attr">"regex_priority"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"paths"</span>: [<span class="string">"/version/\d+/status/\d+"</span>],</span><br><span class="line">        <span class="attr">"regex_priority"</span>: <span class="number">6</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"paths"</span>: [<span class="string">"/version"</span>],</span><br><span class="line">        <span class="attr">"regex_priority"</span>: <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>匹配顺序如下：</p>
<ul>
<li>/version</li>
<li>/version/\d+/status/\d+</li>
<li>/status/\d+</li>
</ul>
<p>前缀路径总是先处理；请求必须仍然匹配路由的主机和方法属性，而Kong将遍历您的路由，直到找到匹配最多规则的路由</p>
<h5 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h5><p>支持捕获组，并且匹配的组将从路径中提取出来，可供插件使用</p>
<p>考虑以下正则表达式：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/version/(?&lt;version&gt;\d+)/users/(?&lt;user&gt;\S+)</span><br></pre></td></tr></table></figure></p>
<p>以下的请求路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/version/1/users/john</span><br></pre></td></tr></table></figure></p>
<p>Kong将把请求路径视为匹配，如果整个路由匹配(考虑到hosts和methods字段)，则提取的捕获组将从ngx中的插件中可用。ctx变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local router_matches = ngx.ctx.router_matches</span><br><span class="line"></span><br><span class="line">-- router_matches.uri_captures is:</span><br><span class="line">-- &#123; &quot;1&quot;, &quot;john&quot;, version = &quot;1&quot;, user = &quot;john&quot; &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="转义特殊字符"><a href="#转义特殊字符" class="headerlink" title="转义特殊字符"></a>转义特殊字符</h5><p>值得注意的是，regex中发现的字符通常是根据RFC 3986保留的字符，因此应该使用percent-encoded。在通过Admin API配置regex路径的路由时，如果需要—确保URL对payload进行编码。例如，使用curl和使用 application/x-www-form-urlencoded MIME类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -i -X POST http://localhost:8001/routes \</span><br><span class="line">    --data-urlencode &apos;uris[]=/status/\d+&apos;</span><br></pre></td></tr></table></figure></p>
<p>Note：curl不会自动地对payload进行URL编码，并注意——data-urlencode的使用情况，它可以防止+字符被Kong的Admin API解码并解释为空格</p>
<h4 id="strip-path"><a href="#strip-path" class="headerlink" title="strip_path"></a>strip_path</h4><p>可能需要指定path前缀以匹配路由，但不应将其包含在上游请求中。为此，通过配置这样的路由，使用strip_path boolean属性：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"/service"</span>],</span><br><span class="line">    <span class="attr">"strip_path"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启用此flag将指示Kong，当匹配此路由并继续代理到服务时，它不应该在上游请求的URL中包含URL路径的匹配部分。</p>
<p>例如，请求如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /service/path/to/resource HTTP/1.1</span><br><span class="line">Host: ...</span><br></pre></td></tr></table></figure></p>
<p>向上游发送的请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /path/to/resource HTTP/1.1</span><br><span class="line">Host: ...</span><br></pre></td></tr></table></figure></p>
<p>同样，如果regex路径是在启用strip_path的路由上定义的，那么请求URL匹配序列的全部将被删除：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"/version/\d+/service"</span>],</span><br><span class="line">    <span class="attr">"strip_path"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下HTTP请求匹配提供的regex路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /version/1/service/path/to/resource HTTP/1.1</span><br><span class="line">Host: ...</span><br></pre></td></tr></table></figure></p>
<p>向上游发送的请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /path/to/resource HTTP/1.1</span><br><span class="line">Host: ...</span><br></pre></td></tr></table></figure></p>
<h3 id="HTTP-method"><a href="#HTTP-method" class="headerlink" title="HTTP method"></a>HTTP method</h3><p>methods字段允许根据其HTTP方法匹配请求，接受多个值，默认值为空(HTTP方法不用于路由)</p>
<p>以下路由允许通过 GET 及 HEAD：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"GET"</span>, <span class="string">"HEAD"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>匹配成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: ...</span><br><span class="line"></span><br><span class="line">HEAD /resource HTTP/1.1</span><br><span class="line">Host: ...</span><br></pre></td></tr></table></figure></p>
<p>上述的规则不会匹配POST或DELETE请求——这使得在路由上配置插件的粒度更细<br>例如，可以设想有两种指向同一服务的路由：</p>
<ul>
<li>无限的未经身份验证的GET请求</li>
<li>只允许经过身份验证和速率限制的POST请求(通过对此类请求应用身份验证和速率限制插件)</li>
</ul>
<h2 id="匹配优先级"><a href="#匹配优先级" class="headerlink" title="匹配优先级"></a>匹配优先级</h2><p>Route可以根据hosts、paths和methods字段定义匹配规则。要使传入请求与路由匹配，必须满足所有现有字段。然而，Kong允许使用包含相同值的字段配置两个或多个路由，从而提供了相当大的灵活性——当发生这种情况时，Kong应用优先级规则。<br>规则：当评估请求时，Kong将首先尝试匹配与大多数规则匹配的路由</p>
<p>如下路由配置：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"example.com"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"hosts"</span>: [<span class="string">"example.com"</span>],</span><br><span class="line">    <span class="attr">"methods"</span>: [<span class="string">"POST"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种路由有一个hosts字段和一个methods字段，因此它将首先由Kong进行评估。这样做，我们就避免了第一个路由覆盖第二个。</p>
<p>这个请求将匹配第一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure></p>
<p>这个请求将匹配第二个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure></p>
<p>按照这种逻辑，如果第三条路由配置为一个hosts字段、一个methods字段和一个uris字段，Kong将首先对其进行评估</p>
<h2 id="代理行为"><a href="#代理行为" class="headerlink" title="代理行为"></a>代理行为</h2><p>上述代理规则详细介绍了Kong如何将传入请求转发到上游服务。下面将详细介绍在Kong与注册路由匹配HTTP请求和请求实际转发之间的内部情况</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>Kong实现了负载平衡功能，以便在上游服务的实例池中分发代理请求，见<a href="https://docs.konghq.com/0.14.x/loadbalancing/" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="插件执行"><a href="#插件执行" class="headerlink" title="插件执行"></a>插件执行</h3><p>Kong是可扩展的，可以通过“插件”将自己hook到代理请求的请求/响应生命周期中。插件可以环境中对代理请求执行各种操作 <strong>和/或</strong> 转换。<br>插件可以配置为全局运行(对于所有代理流量)或在特定的路由和服务上运行。在这两种情况下，都必须通过Admin API创建插件配置。<br>一旦匹配了路由(及其关联的Services实体)，Kong将运行与实体相关联的插件。<strong>在Route上配置的插件在Service上配置的插件之前运行</strong>，但在其他情况下，应用通常的插件关联规则。<br>这些配置好的插件将在它们的访问阶段运行，见<a href="https://docs.konghq.com/0.14.x/plugin-development/" target="_blank" rel="noopener">官方文档</a></p>
<h3 id="代理-amp-上游超时"><a href="#代理-amp-上游超时" class="headerlink" title="代理 &amp; 上游超时"></a>代理 &amp; 上游超时</h3><p>一旦Kong执行了所有必要的逻辑(包括插件)，它就可以将请求转发到上游服务。这是通过Nginx的ngx_http_proxy_module完成的。</p>
<p>可以通过服务的以下属性为Kong和给定的上游连接配置所需的超时：</p>
<ul>
<li>upstream_connect_timeout：以毫秒为单位定义建立到上游服务的连接的超时，默认为60000</li>
<li>upstream_send_timeout：以毫秒为单位定义两个连续写操作之间的超时，用于将请求发送到上游服务，默认为60000</li>
<li>upstream_read_timeout：以毫秒为单位定义从上游服务接收请求的两个连续读操作之间的超时，默认为60000</li>
</ul>
<p>Kong将通过HTTP/1.1发送请求，并设置以下headers：</p>
<ul>
<li>Host: &lt;your_upstream_host&gt;</li>
<li>Connection: keep-alive：允许重用上游连接</li>
<li>X-Real-IP: &lt;remote_addr&gt;：其中$remote_addr是ngx_http_core_module提供的同名变量。注意：$remote_addr可能被ngx_http_realip_module覆盖</li>
<li>X-Forwarded-For: &lt;address>：其中&lt;address>是由ngx_http_realip_module以相同的名称附加到请求头的$realip_remote_addr的内容</li>
<li>X-Forwarded-Proto: <protocol>：其中<protocol>是客户端使用的协议。在$realip_remote_addr是受信任地址之一的情况下，如果提供相同名称的请求header，就会转发。否则，将使用ngx_http_core_module提供的$scheme变量的值</protocol></protocol></li>
<li>X-Forwarded-Host: <host>：其中<host>是客户端发送的host名。在$realip_remote_addr是受信任地址之一的情况下，如果提供相同名称的请求header，就会转发。否则，将使用ngx_http_core_module提供的$host变量的值</host></host></li>
<li>X-Forwarded-Port: <port>：其中<port>是接受请求的服务器端口。在$realip_remote_addr是受信任地址之一的情况下，如果提供相同名称的请求header，就会转发。否则，将使用ngx_http_core_module提供的$server_port变量的值</port></port></li>
</ul>
<p>所有其他请求header都按原样由Kong转发。<br>在使用WebSocket协议时，有一个例外。在这种情况下，Kong将设置以下头信息，以便在客户端和您的上游服务之间升级协议：</p>
<ul>
<li>Connection: Upgrade</li>
<li>Upgrade: websocket</li>
</ul>
<p>关于这部分，更多<a href="https://docs.konghq.com/0.14.x/proxy/#proxy-websocket-traffic" target="_blank" rel="noopener">可见文档</a></p>
<h3 id="错误-amp-重试"><a href="#错误-amp-重试" class="headerlink" title="错误 &amp; 重试"></a>错误 &amp; 重试</h3><p>当代理期间发生错误时，Kong将使用底层的Nginx重试机制将请求传递给下一个上游<br>这里有两个可配置的元素：</p>
<ul>
<li>重试次数：可以使用retries 属性为每个服务配置重试次数，见<a href="https://docs.konghq.com/0.14.x/admin-api/" target="_blank" rel="noopener">文档</a></li>
<li>什么构成了一个错误：Kong使用Nginx默认值，这意味着在与服务器建立连接、向其传递请求或读取响应头时发生错误或超时</li>
</ul>
<p>第二个选项基于Nginx的[proxy_next_upstream][proxy_next_upstream]指令。此选项不能通过Kong直接配置，但可以使用自定义Nginx配置添加，见<a href="https://docs.konghq.com/0.14.x/configuration/" target="_blank" rel="noopener">文档</a></p>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><p>Kong接收来自上游服务的响应，并以流的方式将其发送回下游客户端。此时，Kong将执行添加到Route和/或Service中的后续插件，这些插件在header_filter阶段实现了一个钩子。<br>一旦执行了所有已注册插件的header_filter阶段，Kong将添加以下标题，并将全部标题发送给客户：</p>
<ul>
<li>Via: kong/x.x.x：x.x.x是Kong的版本</li>
<li>X-Kong-Proxy-Latency: <latency>：latency是Kong从客户端接收请求并将请求发送到上游服务之间的时间(以毫秒为单位)</latency></li>
<li>X-Kong-Upstream-Latency: <latency>：等待时间是Kong等待上游服务响应的第一个字节(以毫秒为单位)</latency></li>
</ul>
<p>一旦消息头被发送到客户端，Kong将开始为实现body_filter钩子的Route和/或Service执行注册插件。由于Nginx的流特性，这个钩子可能被调用多次。由body_filter钩子成功处理的上游响应的每个块都被发送回客户端，可见<a href="https://docs.konghq.com/0.14.x/plugin-development/" target="_blank" rel="noopener">文档</a></p>
<h2 id="配置回退路由"><a href="#配置回退路由" class="headerlink" title="配置回退路由"></a>配置回退路由</h2><p>作为一个Kong提供实际用例和灵活性的例子，尝试实现一个”fallback Route”，所以为了避免Kong与HTTP 404响应，”no route found”，我们可以捕捉这些请求，并将它们代理给一个特殊的上游服务，或者应用插件（例如，这样的插件可以使用不同的状态码或响应终止请求，而无需代理请求）</p>
<p>fallback Route：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"paths"</span>: [<span class="string">"/"</span>],</span><br><span class="line">    <span class="attr">"service"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"..."</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对Kong发出的任何HTTP请求实际上都与此路由匹配，因为所有uri都以根字符/作为前缀。从请求路径部分我们知道，最长的URL路径首先由Kong计算，因此/ path最终将由Kong计算，并且有效地提供了一个“后备”路径，仅作为最后的手段进行匹配。然后，可以将流量发送到一个我们希望的特殊Service或应用任何插件</p>
<h2 id="为路由配置SSL"><a href="#为路由配置SSL" class="headerlink" title="为路由配置SSL"></a>为路由配置SSL</h2><h3 id="限制客户端协议-HTTP-HTTPS"><a href="#限制客户端协议-HTTP-HTTPS" class="headerlink" title="限制客户端协议(HTTP/HTTPS)"></a>限制客户端协议(HTTP/HTTPS)</h3><h2 id="代理WebSocket流量"><a href="#代理WebSocket流量" class="headerlink" title="代理WebSocket流量"></a>代理WebSocket流量</h2><h3 id="WebSocket和TLS"><a href="#WebSocket和TLS" class="headerlink" title="WebSocket和TLS"></a>WebSocket和TLS</h3><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li><a href="https://docs.konghq.com/0.14.x/configuration/#proxy_listen" target="_blank" rel="noopener">https://docs.konghq.com/0.14.x/configuration/#proxy_listen</a></li>
<li><a href="https://docs.konghq.com/0.14.x/proxy" target="_blank" rel="noopener">https://docs.konghq.com/0.14.x/proxy</a></li>
</ul>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/API-Gateway/" rel="tag"># API Gateway</a>
          
            <a href="/tags/Kong/" rel="tag"># Kong</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/posts/kong_dashboard/" rel="next" title="Kong——Dashboard">
                <i class="fa fa-chevron-left"></i> Kong——Dashboard
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/posts/kong_admin_api/" rel="prev" title="Kong——Admin API文档">
                Kong——Admin API文档 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Ryoma" />
            
              <p class="site-author-name" itemprop="name">Ryoma</p>
              <p class="site-description motion-element" itemprop="description">Ryoma's Blog</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">63</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">61</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/JianmingXia" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:xiajianming_xjm@163.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#术语"><span class="nav-number">1.</span> <span class="nav-text">术语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概览"><span class="nav-number">2.</span> <span class="nav-text">概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#未匹配的请求"><span class="nav-number">2.1.</span> <span class="nav-text">未匹配的请求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何配置服务"><span class="nav-number">3.</span> <span class="nav-text">如何配置服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#添加Service"><span class="nav-number">3.1.</span> <span class="nav-text">添加Service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加Route"><span class="nav-number">3.2.</span> <span class="nav-text">添加Route</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#routes"><span class="nav-number">3.2.1.</span> <span class="nav-text">routes</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#services-xxx-routes"><span class="nav-number">3.2.2.</span> <span class="nav-text">services/xxx/routes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#路由及匹配功能"><span class="nav-number">4.</span> <span class="nav-text">路由及匹配功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#匹配案例"><span class="nav-number">4.1.</span> <span class="nav-text">匹配案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#路由配置"><span class="nav-number">4.1.1.</span> <span class="nav-text">路由配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匹配通过"><span class="nav-number">4.1.2.</span> <span class="nav-text">匹配通过</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匹配失败"><span class="nav-number">4.1.3.</span> <span class="nav-text">匹配失败</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Host-Header"><span class="nav-number">4.2.</span> <span class="nav-text">Host Header</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础配置"><span class="nav-number">4.2.1.</span> <span class="nav-text">基础配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用通配符的主机名"><span class="nav-number">4.2.2.</span> <span class="nav-text">使用通配符的主机名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#preserve-host"><span class="nav-number">4.2.3.</span> <span class="nav-text">preserve_host</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Path"><span class="nav-number">4.3.</span> <span class="nav-text">Path</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础配置-1"><span class="nav-number">4.3.1.</span> <span class="nav-text">基础配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用正则表达式"><span class="nav-number">4.3.2.</span> <span class="nav-text">使用正则表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#匹配顺序"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">匹配顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#捕获组"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">捕获组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#转义特殊字符"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">转义特殊字符</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#strip-path"><span class="nav-number">4.3.3.</span> <span class="nav-text">strip_path</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-method"><span class="nav-number">4.4.</span> <span class="nav-text">HTTP method</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配优先级"><span class="nav-number">5.</span> <span class="nav-text">匹配优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理行为"><span class="nav-number">6.</span> <span class="nav-text">代理行为</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#负载均衡"><span class="nav-number">6.1.</span> <span class="nav-text">负载均衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插件执行"><span class="nav-number">6.2.</span> <span class="nav-text">插件执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代理-amp-上游超时"><span class="nav-number">6.3.</span> <span class="nav-text">代理 &amp; 上游超时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误-amp-重试"><span class="nav-number">6.4.</span> <span class="nav-text">错误 &amp; 重试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应"><span class="nav-number">6.5.</span> <span class="nav-text">响应</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置回退路由"><span class="nav-number">7.</span> <span class="nav-text">配置回退路由</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为路由配置SSL"><span class="nav-number">8.</span> <span class="nav-text">为路由配置SSL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#限制客户端协议-HTTP-HTTPS"><span class="nav-number">8.1.</span> <span class="nav-text">限制客户端协议(HTTP/HTTPS)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#代理WebSocket流量"><span class="nav-number">9.</span> <span class="nav-text">代理WebSocket流量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WebSocket和TLS"><span class="nav-number">9.1.</span> <span class="nav-text">WebSocket和TLS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资料"><span class="nav-number">10.</span> <span class="nav-text">资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ryoma</span>

  

  
</div>




  <div class="powered-by"><a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Gemini</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>




















  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  

  
    <script id="dsq-count-scr" src="https://ryoma-blog.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'https://blog.ryoma.top/posts/kong_proxy/';
        this.page.identifier = 'posts/kong_proxy/';
        this.page.title = 'Kong——Proxy文档';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://ryoma-blog.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        $(function () {
          var offsetTop = $('#comments').offset().top - $(window).height();
          if (offsetTop <= 0) {
            // load directly when there's no a scrollbar
            loadComments();
          } else {
            $(window).on('scroll.disqus_scroll', function () {
              var scrollTop = document.documentElement.scrollTop;
              if (scrollTop >= offsetTop) {
                $(window).off('.disqus_scroll');
                loadComments();
              }
            });
          }
        });
      
    </script>
  












  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>

---
title: 你不知道的JavaScript——ES6及更新版本
date: 2017/12/25 12:00:00
tags:
  - JavaScript
categories: 
  - [阅读笔记]
  - [JavaScript]
---

## ES？现在与未来

### 版本

版本标签？

### transpiling

transformation + compiling——转换 + 编译：利用专门的工具将ES6代码转换为等价的可以在ES5环境下工作的代码

#### shim/polyfill

并非所有的ES6新特性都需要使用transpiler，还可以使用polyfill。

语法不能polyfill，而API通常可以
<!-- more -->

## 语法

### 块作用域声明

#### let 声明

#### const 声明

##### 是否使用const

> 要避免可能令人迷惑的代码，只对你有意表明不变的变量使用const。
>
> 不要依赖const来规范代码行为，而是在意图清晰的时候，把它作为一个表明意图的工具

#### 块作用域函数

### spread/rest

### 默认参数值

####  默认值表达式

默认表达式是惰性求值的，只在需要的时候运行——参数的值省略或为undefined时

> Function.prototype是一个没有操作的空函数——可用于作为没有操作的空函数的默认值

### 解构

- 数组解构
- 对象解构

#### 对象属性赋值模式

```js
function bar() {
  return {
    x: 4,
    y: 5,
    z: 6,
  };
}

var { x: bam, y: baz, z: bap } = bar();

console.log(bam, baz, bap); // 4 5 6
console.log(x, y, z); // ReferenceError
```

#### 不只是声明

如果变量是已声明的，解构实际上是一个赋值过程

> 如果是对象解构，并且省略了声明符：let/const等，赋值表达式需要使用()包围，否则会被视为块语句

另外，赋值表达式并不必须是变量标识符，任何合法的赋值表达式都可以：

- 对象属性访问
- []计算的属性的表达式

甚至可以做到“交换两个变量”

#### 重复赋值

对象解构形式允许多次列出同一个源属性

> 如果运用了很复杂的对象解构，需要主要代码格式——解构的目的不只是为了打字更少，而是为了可读性更强

##### 解构赋值表达式

对象或者数组解构的赋值表达式的完成值是所有右侧对象/数组的值：

```js
var o = {
  a: 1,
  b: 2,
  c: 3
};

var a, b, c, p;

p = { a, b, c } = o;

console.log(a, b, c); // 1 2 3
p === o; // true
```

通过持有对象/数组的值作为完成值，可以把解构赋值表达式组成链~

### 太多，太少，刚刚好

对于数组解构或对象解构赋值来说，我们不一定要把存在的所有值都用来赋值。

另外 `...` 也可用于解构赋值中

#### 默认值赋值

两种解构都可以提供一个用来赋值的默认值

另外，请不要写出晦涩难懂的代码：

![](https://img.ryoma.top/YouDontKnowJS/es6-beyond-0.png)

#### 嵌套解构

如果解构的值中有嵌套的对象或数组，也可以解构这些嵌套的值

#### 解构参数

用于参数解构

##### 解构默认值 + 参数默认值

解构默认值与函数参数默认值的区别！！！

##### 嵌套默认：解构并重组

更复杂对象的数组重组

### 对象字面量扩展

#### 简洁属性

#### 简洁方法

##### 简洁未命名

优点：简洁方便

缺点：如果方法需要执行递归或事件绑定/解绑定，不要尝试使用此方法

##### ES5 Getter/Setter

#### 计算属性名

最常见的用法可能是和Symbols使用；当有prefix的场景也可以考虑

#### 设定[[Prototype]]

使用setPrototypeOf

#### super对象

> super只允许在简洁方法中出现

### 模板字面量

优点：

- 分散多行
- 支持嵌入基本的字符串插入表达式，会被自动解析和求值

#### 插入表达式

`${}` 内可以出现任何合法的表达式，包括函数调用、在线函数表达式调用，甚至其他插入字符串字面量！

##### 表达式

插入字符串字面量在它出现的词法作用域中，没有任何形式的动态作用域

#### 标签模板字面量

很高级的用法，比如将数字格式化为美元表示法

### 箭头函数

箭头函数总是函数表达式；并不存在箭头函数声明。

箭头函数是匿名函数表达式——没有用于递归或者事件绑定/解绑定的命名引用

>  作者：箭头函数带来的可读性提升与被转换函数的长度负相关。这个函数越长，带来的好处越小

#### 不只是更短的语法，而是this

在箭头函数内部，this绑定不是动态的，而是词法的。

- 如果有一个简短单句在线函数表达式，其中唯一的语句是return某个计算的值，且这个函数内部没有引用，且没有自身引用（递归、事件绑定与解绑定），且不会要求函数执行这些，可以使用=>
- 如果有一个内层函数表达式，依赖于在包含它的函数中调用var self = this hack或者.bind(this)来确保适当的this绑定，可以使用=>
- 如果内层函数表达式依赖于封装函数中像var  args = Array.prototype.slice.call(arguments)来保证arguments的词法复制，可以使用=>
- 所有其他情况：函数声明、较长的多语句函数表达式、需要词法名称标识符（递归等）的函数，以及不符合上述特征的函数，避免使用

可视化决策图：

![](https://img.ryoma.top/YouDontKnowJS/es6-beyond-1.png)

### for..of 循环

JS中默认为iterable的标准内建值包括：

- Arrays
- Strings
- Generators
- Collections/TypedArrays

### 正则表达式

>  抽个时间看一下，很容易忘记

### 数字字面量扩展

#### 反向转换

```js
var a = 42;

console.log(a.toString());
console.log(a.toString(8));
console.log(a.toString(16));
console.log(a.toString(2));
// 42 52 2a 101010
```

这种方式可以传2-36之间的一个数字

### Unicode

Uniccode字符范围从0x0000 - 0xFFFF，包含可能看到和接触到的所有标准打印字符

#### 支持Unicode的字符串运算

### 符号

Symbol没有字面量形式

注意事项：

- 不能也不应该对Symbol使用new，它并不是一个构造器，也不是一个对象
- 传给Symbol的参数是可选的，如果传入的话，应该是一个为这个Symbol的用途给出用户友好描述的字符串
- typeof的输出是一个新的值："symbol"

存在的意义：

- 创建一个类似字符串的，不会与其它任何值冲突的值：比如事件监听

#### 符号注册

在事件监听中添加注册事件类型，这个类型可能要公开到全局作用域中，如果要改进这种模式，可以使用**全局符号注册**——global symbol registry：Symbol.for

Symbol.for会在全局符号注册表中搜索，来查看是否有描述文件系统的符号已经存在，如果有就返回它——全局注册表把符号值本身根据其描述文字作为单例处理

可以使用Symbol.keyFor()来提取注册符号的描述文本（键值）

#### 作为对象属性的符号

如果把符号作为对象的属性/键值，那么它会以一种特殊的方式存储，使得这个属性不出现在对这个对象的一般属性枚举中

- Object.getOwnPropertySymbols()

##### 内置符号

如Symbol.iterator

## 代码组织

编写JS代码是一回事，而合理组织代码则是另一回事——利用通用模式来组织和复用代码，显著提高了代码的可读性和可理解性。

### 迭代器

> 迭代器是一个结构化的模式，用于从源以一次一个的方式提取数据。

#### 接口

#### next()迭代

```js
var m = new Map();
m.set('foo', 42);
m.set({ cool: true }, 'hello world');

var it1 = m[Symbol.iterator]();
console.log(it1.next());
console.log(it1.next());

var it2 = m.entries();
console.log(it2.next());
console.log(it2.next());
```

#### 可选的return()和throw()

#### 迭代器循环

```js
var arr = [1, 2, 3, 4, 5];

for (var v of arr) {
  console.log(v);
}

var it = arr[Symbol.iterator]();
for (var res; (res = it.next()) && !res.done; ) {
  console.log(res.value);
}
```

#### 自定义迭代器

只要遵循适当的接口，就可以构造自己的迭代器

还有一种迭代器，是用来在一系列动作上运行，一次一个条目——这种特定的用法强调了迭代器可以作为一个模式来组织功能，而不仅仅是数据

#### 迭代器消耗

除了通过for..of来消耗迭代器，还可以通过数组解构的方式来消耗

### 生成器

#### 语法

##### 运行生成器

要继续运行生成器函数，需要执行xx.next()

##### yield

生成器中还有一个可以在其中使用的新关键字

##### yield*

#### 迭代器控制

> 生成器由迭代器控制

#### 提前完成

生成器上附着的迭代器支持可选的return()和throw()方法，这两个方法都有立即终止一个暂停的生成器的效果

#### 错误处理

？？？

#### Transpile 生成器

- 创建一个函数，执行返回一个迭代器
- 需要内部变量来记录“生成器”逻辑步骤内部的当前位置——state：初始态、等待yield完成、生成器完毕

#### 生成器使用

- 产生一系列值

  比如随机字符串或者递增数

- 顺序执行的任务队列

  表示算法中步骤的流控制，其中每个步骤要求从外部源获得数据

## 其它

### Unicode

### 正则表达式

### 生成器

未完待续。。。
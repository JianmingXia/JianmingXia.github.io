---
title: 你不知道的JavaScript——作用域与闭包
date: 2017/9/21 12:00:00
tags:
  - JavaScript
categories: 阅读笔记
---

## 前言
> 英文版：https://github.com/getify/You-Dont-Know-JS

JS不愧是入门最简单的语言之一，自从工作之后，基本没进行学习就可以编写JS代码了。写出来的代码能工作，就再也不管其细节了，最近发现一个写了一年多的前端代码，由于各开发人员水平参差不齐，没有标准，导致现在的前端代码已经很难维护了，赶紧自己先充一波电再说。
<!-- more -->

## 作用域是什么

### 编译原理

> 作者的看法：尽管通常将JavaScript归类为“解释执行”或“动态”语言，但事实上它是一门编译语言——但与传统的编译语言不同，它并非提前编译，编译结果也无法移植。

传统的编译语言执行：

- 分词/词法分析（Tokenizing/Lexing）：将由字符组成的字符串分解成有意义的代码块——词法单元（token）
- 解析/语法分析（Parsing）：将词法单元流转换成一个由元素逐级嵌套所组成的代表程序语法结构的树——抽象语法树（Abstract Syntax Tree, AST）
- 代码生成：将AST转换成可执行代码的过程被称为代码生成。

较于编译过程只有三个步骤的语言的编译器，JavaScript引擎要更复杂：

- 在词法分析与代码生成阶段对运行性能进行优化
- 对冗余元素进行优化

### 理解作用域

#### 关键点

- 引擎：负责整个JavaScript程序的编译及执行过程
- 编译器：负责语法分析及代码生成等
- 作用域：负责收集并维护由所有声明的标识符组成的一系列查询，并实施一套非常严格的规则，确定标识符的访问权限

#### var a = 2

- 编译器会在当前作用域声明一个变量（如果之前没有声明过）
- 运行时引擎会在作用域中查找该变量，如果能够找到就会赋值

#### 编译器有话说

- LHS：赋值操作的目标
- RHS：赋值操作的源头

#### 理解LHS 及 RHS

![](https://img.ryoma.top/YouDontKnowJS/top_1-1.png)

### 作用域嵌套

引擎从当前执行作用域开始查找变量，如果找不到，向上一级继续查找；当抵达最外层的全局作用域时，查找停止

### 异常

为什么理解LHS 和 RHS 很重要？

不成功的LHS：

- 自动创建一个全局变量（非严格模式下）
- 抛出ReferenceError（严格模式下）

错误说明：

- ReferenceError：与作用域判别失败相关
- TypeError：作用域判别成功，但是对结果的操作非法或不合理

## 词法作用域

作用域的两种工作模型：

- 大多数编程语言采用的词法作用域
- 动态作用域：Bash脚本、Perl中的一些模式

### 词法阶段

简单来说，词法作用域是定义在词法阶段的作用域——大部分情况下，词法作用域是由写代码时将变量和块作用域写在哪里决定的。

- 查找：作用域查找会在找到第一个匹配的标识符时停止（遮蔽效应）

### 欺骗词法

社区认为这两种机制并不是好主意，但关键是：欺骗词法作用域会导致性能下降

#### eval

**eval(...)**可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在一样。

> 在严格模式下，eval有其自己的词法作用域，此时其中的声明无法修改所在的作用域

#### with

with通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身——与eval不同，with声明实际上在根据传递的对象凭空创建了一个全新的词法作用域。

> with在严格模式下会被完全禁止

#### 性能

使用eval和with会带来什么？

- 能实现更复杂的功能，代码更具有拓展性？

JavaScript引擎会在编译阶段进行数项性能优化，其中，有些优化依赖于代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，这样能在执行中快速定位标识符。而有了with和eval之后，所有的优化可能是无意义的，从而导致代码运行得更慢。

## 函数作用域和块作用域

### 函数中的作用域

属于这个函数的全部变量都可以在整个函数的范围内使用及复用（在嵌套的作用域中也可以）。

### 隐藏内部实现

最小特权原则：应该最小限度地暴露必要内容，将其他内容都“隐藏”起来，比如模块、API设计等

#### 规避冲突

可以避免同名标识符之间的冲突。

- 全局命名空间：第三方库一般会在全局作用域中声明一个独特名字，用作库的命名空间，需要暴露给外部的功能都会成为这个命名空间的属性
- 模块管理：通过依赖管理器将库的标识符显式的导入另一个特殊的作用域中

### 函数作用域

使用函数屏蔽内部的变量及函数定义：会引入函数名到所在作用域；需要显示调用。

引入函数表达式，需要注意它与函数声明不同。

| 函数声明                                               | 函数表达式                     |
| ------------------------------------------------------ | ------------------------------ |
| 看function关键字出现在声明中的位置，function是第一个词 | function不是第一个词           |
| 标识符在所在作用域中                                   | 标识符在函数表达式自身的函数中 |

#### 匿名 & 具名

匿名函数表达式：function()没有标识符

- 在栈追踪时不会显示有意义的函数名，调试会比较困难
- 没有函数名：递归如何处理？使用过期的**arguments.callee**；事件触发后事件监听器解绑
- 匿名函数省略了对于代码可读性/可理解性很重要的函数名

#### 立即执行函数表达式

IIFE：Immediately Invoked Function Expression

```js
(function foo(){ .. })()	
```

变体（没有区别）：

```js
(function foo(){ .. }())
```

IIFE可以传参。

IIFE还有一种变化用途：倒置代码的运行顺序，将需要运行的函数放置第二位（在UMD——Universal Module Definition中广泛使用）：

```js
var a = 2;

(function IIFE(def){
    def(window);
})(function def(global) {
    var a = 3;
    console.log(a); // 3
    console.log(global.a); // 2
})
```

### 块作用域

表面上看，JavaScript中并没有块作用域相关功能

#### with

用with创建出的作用域仅在with声明中而非外部作用域中有效

#### try/catch

catch中会创建一个块作用域，其中声明的变量仅在catch中有效使用

#### let

let为其声明的变量隐式绑定所在的作用域

- 垃圾收集：使用块作用域告知引擎进行垃圾收集
- let循环：for循环中的let不仅将i绑定到for循环的块中，并且将其重新绑定到了循环的每一次迭代中

#### const

与let类似，基础类型的数据是不可再重新赋值的。

## 提升

先声明、再赋值。

在JS中，声明本身会被提升，但赋值及其他运行逻辑不会提升。

> 函数声明会被提升，但是函数表达式不会

### 函数优先

函数声明与变量声明都会被提升：但函数会首先被提升，然后才是变量

```js
foo();

var foo;

function foo() {
  console.log(1);
}

foo = function() {
  console.log(2);
};

// 1
```

虽然重复的var声明会被忽略，但是后面的函数声明依然可以覆盖前面的。

```js
foo();

if (true) {
  function foo() {
    console.log(1);
  }
} else {
  function foo() {
    console.log(2);
  }
}
// 不可靠
```

这个行为可能在不同的环境中有不同的表现，chrome v68中运行返回：TypeError

## 作用域闭包

### 定义

> 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数在当前词法作用域之外执行

### 模块

- 为创建内部作用域而调用了一个包装函数
- 包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包

#### 现代的模块机制

大多数模块依赖加载器/管理器本质上都是将这种模块定义封装进一个友好的API。

#### 未来的模块机制

ES6的模块没有”行内“样式，必须被定义在独立的文件中。

## 其它

### 动态作用域

动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。

作用域链是基于调用栈的，而不是代码中的作用域嵌套。

### JS中的apply, call
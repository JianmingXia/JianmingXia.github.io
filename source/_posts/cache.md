---
title: 缓存杂谈
date: 2018/07/26 21:00:00
tags:
  - 阅读笔记
categories: 缓存
---

缓存是互联网分层架构中非常重要的一部分，通常用来降低数据库压力，提升系统整体性能，降低响应时间。

## 进程内缓存
在很长一段时间内，由于受到公司游戏C++项目的影响，我们一直使用进程内缓存：将数据缓存在服务的进程中。<br />一般采用常用的数据结构来存储数据，比如map、set或是list等。

### 缓存内容
不仅仅是普通的json 及 html内容，在内存中更多的是缓存对象（比如团队中User，使用一个UserMap根据user_id 缓存User）。

<!-- more -->

### 优势
数据读取不需要每次都读取数据表；先去内存中获取，若获取不到，再去读数据表，减小了数据表的压力
* 与进程外缓存相比（Redis等）：进程内缓存节省了网络开销，从而节省了内网带宽 & 延时更低

### 缺点
* 单一存储：每个服务进程都需要对数据进行缓存，这样带来的问题是数据的一致性难以保证
* 不方便扩展：很容易受到单机内存的限制

### 进程内缓存的一致性如何保证
* 单节点通知其他节点：这也是我们之前使用的方案，但如果多个节点支持多支持写多个资源时，网状连接极其复杂
* 通过MQ通知：引入了MQ，但同时也会让系统更加复杂
* 定时更新：放弃了实时一致性，一段时间内会有脏数据

总而言之，节点越多，数据冗余更多。同时同时更新的原子性难以保证，一致性难以保证

### 为什么不能频繁使用进程内缓存
分层架构设计中有一条准则：服务层要做到无状态，这样才能水平扩展服务

### 什么时候可以使用进程内缓存
* 只读数据（当然进程外缓存也可以）
* 极其高并发，如果透传后端压力较大的场景：比如秒杀这类场景，需要服务层挡住流量
* 允许数据不一致的服务

## 缓存误用
### 把缓存作为服务与服务之间传递数据的媒介
#### 描述
* Server1 和 Server2 约定 key 及 value，通过缓存传递数据
* Server1 写入数据，Server2 读取数据，从而达到服务直接传输数据

#### 问题
* 数据管道、数据通知场景，MQ更加适合（让专业的软件干专业的事情）
* 多个服务关联同一个缓存实例，导致服务耦合

### 使用缓存未考虑雪崩
#### 缓存的用法
* 服务先读缓存，缓存命中则返回
* 缓存不命中，则读数据库

#### 缓存雪崩
如果缓存挂了，请求会直接落到数据库，可能会将数据库压垮，导致系统不可服务

#### 如何应对
提前做容量预估，如果缓存挂了，数据库仍然可以提供服务，可执行上述方案。否则，对于缓存需要进一步设计

#### 高可用缓存
使用高可用缓存集群，一个缓存实例挂了，能够自动做故障转移

#### 缓存水平切分
一个缓存实例挂了，不至于所有的流量都压到数据库上

### 调用方缓存数据
服务调用方获取到数据后，也缓存了数据。在下次接到请求后，先读自己的缓存，再决定是否调用服务。

这样带来的问题是：
* 当服务修改db中的数据，淘汰了服务的缓存之后，调用方的缓存依然存在，导致不一致
* 还有人说可以通过MQ通知调用方淘汰数据——难道下游的服务要依赖上游的调用方？？？

### 多服务共用缓存实例
> 第一个误用指的是多个服务通过缓存传递数据，这里指的是多个服务共用缓存实例。


多个服务共用缓存实例依然有问题：
* key 冲突：可能冲掉对方的数据（需要服务提前约定key，确保不冲突）
* 不同服务对应的数据量、吞吐量不一样；个别服务的高负载可能会影响到其它服务

每个服务都应该私有化自己的数据存储，对上游屏蔽底层的复杂性。

## 资料
* [进程内缓存，究竟怎么玩](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961296&idx=1&sn=883a46db0e4b4fe8bd2de5a370e3304e&chksm=bd2d020c8a5a8b1a2938b07da1a42648d562c559d573b5700e48ea5318dac3ee246b2e6ce908&scene=21#wechat_redirect)
* [缓存，你真的用对了么？](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961307&idx=1&sn=2ea36d014299c7870a0b40575578469e&chksm=bd2d02078a5a8b111d0caa649ae93f050ee6d4168c43322c2cf8cd8387becdd9b78a7202daa0&scene=21#wechat_redirect)

---
title: Redis 分布式锁
date: 2018/08/06 21:00:00
tags:
  - Redis
  - 分布式锁
categories: 缓存
---

## 说明

在之前的C++项目中，当需要修改某些内容的时候，考虑到并发读写的场景，一般都会加上一个“写锁”，此时读写场景中“读写锁”都会等待“写锁”释放（阻塞操作），当“写锁”释放后，“读锁”占位，进行读的操作。

从之前看的redis基础内容来看，Redis是没有办法直接加锁的，但是我们又不得不考虑这件事。否则，在高并发的场景下，数据会成什么样子，鬼知道呢？
<!-- more -->

## 分布式锁

### 锁的重要性

之前看到Redis中有事务的概念，在开启事务时，如果其它客户端修改了目标值，事务就会失败。一般来说，我们会在事务失败后，不断重试。但是，这样有个问题：在负载不断增加的情况下，事务由于执行失败而反复重试，而频繁重试会导致乐观锁的效率会很低。

事务失败然后重试其实是乐观锁的实现，有兴趣的可以查看乐观锁。

### 锁的实现
#### 占坑
分布式锁本质上要实现的是先“占坑”，当坑被占后，当别的进程也要来占时，就只能重试或放弃。 

在Redis中，使用SETNX实现“占坑”——set if not exists，只允许被一个客户端占坑。先来先占，当坑被占的时候，所有的客户端都无法再占坑，只能等待坑被释放。

#### 漏洞
但是，上面这种方式是有漏洞的：

- 如果占坑的客户端挂了，这个坑就再也不会被释放了
- 有了上一个问题，我们可能会想到使用expire设置过期时间——但是SETNX和EXPIRE不是原子操作，假如两个命令之间挂掉了怎么办
- 假如第一个客户端占了坑，并且操作超时；此时第二个客户端也占了坑，开始进行操作；第一个客户端完成了操作，然后将坑释放了。。。此时，第二个客户端占了一个假坑

### 锁冲突处理
当客户端请求加锁没成功：

- 直接抛出异常，通知用户稍后重试——适合处理由用户直接发起的请求，由用户决定是否重试
- sleep 一段时间再重试——考虑出现碰撞频繁的情况，会出现阻塞的情况，即使可以设置重试限制，还是需要慎重使用
- 将请求转移至延时队列——适合异步消息处理

## 锁的优化

上面列了3个问题，其中，第二个问题是为了解决第一个问题而产生的，实际上，我们解决第二、三个问题即可：

### EXPIRE问题

在之前的版本中，需要分别使用SETNX和EXPIRE实现锁，但是由于不是原子操作，还需要保证EXPIRE必定执行成功。实际上从Redis2.6.12开始，通过使用SET命令新添加的可选选项，可以有同时运行SETNX和EXPIRE命令的效果。

### 超时引发的问题

上面第三个问题就是超时引起的一个问题，导致释放锁的时候比较混乱。

解决方案：为占坑的key对应的value设置为一个随机数，在释放锁时先进行比较，然后再删除 key，这样就可以确保当前线程占用的锁不会被其它线程释放。 

### 细粒度锁

在高负载的情况下，使用锁可以减少重试次数、降低延迟时间、提升性能。但是，如果我们将锁的粒度设置得很大的话，很多操作都会拼命请求锁，这个时候的效率就会降低，此时需要考虑将加锁的粒度调整至合适的大小。

需要注意的是：判断应该锁住整个结构还是应该锁住结构中的一小部分是一件需要注意的事情，按场景去分析。

## 更多

我们目前使用的腾讯云的Redis服务，提供了高可用性，并且自带主备，考虑一个场景：

- 客户端1从Master获取了锁
- Master宕机了，存储锁的key还没有来得及同步到Slave上
- Slave升级为Master
- 客户端2从新的Master获取到了对应同一个资源的锁

此时，会存在两个客户端同时修改同一资源的场景，如果不能容忍这种情况发生，分布式锁还需要继续挖掘，可以参考下方的资料。

## 资料

- [《redis实战》](http://redisinaction.com/)6.2分布式锁
- http://zhangtielei.com/posts/blog-redlock-reasoning.html
- http://www.redis.cn/topics/distlock.html